{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "0fa90238",
   "metadata": {},
   "source": [
    "# Traffic Simulation Model Analysis and Improvements\n",
    "\n",
    "## 1. How the Model Works: Detailed Analysis\n",
    "\n",
    "### A. Overall Architecture\n",
    "\n",
    "The traffic simulation model follows an agent-based approach with two main components:\n",
    "\n",
    "1. **Road Network**: Represented using a directed graph from NetworkX, where:\n",
    "   - Nodes represent intersections or road junctions\n",
    "   - Edges represent road segments connecting these junctions\n",
    "   - Edge attributes include travel time, speed limits, and length\n",
    "\n",
    "2. **Cars**: Individual agents that navigate through the network, where each car:\n",
    "   - Has a current location (node) and destination\n",
    "   - Plans a path (series of nodes to traverse)\n",
    "   - Tracks its travel time and rerouting behavior\n",
    "\n",
    "The simulation progresses in discrete time steps, with each step representing one unit of simulated time during which cars attempt to move along their paths unless they encounter traffic jams.\n",
    "\n",
    "### B. Model Components\n",
    "\n",
    "#### RoadNetwork Class\n",
    "\n",
    "This class handles the creation and management of road networks with the following features:\n",
    "\n",
    "- **Initialization**: Creates a road network centered around a specified address using OpenStreetMap data\n",
    "- **Travel Time Calculation**: Adds travel time attributes to edges based on speed limits and road length\n",
    "- **Validation**: Ensures all edges have valid travel times for path calculations\n",
    "\n",
    "#### Car Class\n",
    "\n",
    "This simple class represents individual vehicles with properties such as:\n",
    "\n",
    "- Current location (node ID)\n",
    "- Destination (node ID)\n",
    "- Path (list of nodes to traverse)\n",
    "- Travel time (accumulated time spent traveling)\n",
    "- Reroute count (how many times the car changed its route)\n",
    "- Journey completion statistics\n",
    "\n",
    "#### TrafficSimulator Class\n",
    "\n",
    "This class orchestrates the simulation with methods for:\n",
    "\n",
    "1. **Creating Cars**: Randomly assigns start and end points within the connected component of the graph\n",
    "2. **Moving Cars**: Updates car positions based on traffic conditions\n",
    "3. **Traffic Calculation**: Determines traffic density on each edge\n",
    "4. **Traffic Jam Handling**: Implements rerouting when cars encounter congestion\n",
    "5. **Data Collection**: Gathers metrics on traffic patterns for analysis\n",
    "\n",
    "### C. Simulation Process\n",
    "\n",
    "1. **Initialization**: \n",
    "   - Load road network from OpenStreetMap\n",
    "   - Calculate travel times for all road segments\n",
    "   - Create cars with random valid start and destination points\n",
    "   - Calculate initial paths using shortest path algorithm (weighted by travel time)\n",
    "\n",
    "2. **Simulation Step**:\n",
    "   - Calculate current traffic on all edges\n",
    "   - For each car:\n",
    "     - Check if it has reached its destination\n",
    "     - If no path exists, calculate a new one\n",
    "     - Check traffic on the next road segment\n",
    "     - Move the car if no traffic jam, otherwise possibly reroute\n",
    "   - Collect metrics about traffic patterns\n",
    "\n",
    "3. **Traffic Jam Handling**:\n",
    "   - A road segment is considered jammed if the number of cars exceeds the threshold\n",
    "   - Cars on jammed segments:\n",
    "     - Accumulate travel time (delayed by traffic)\n",
    "     - Have a probability to reroute (find alternative path)\n",
    "     - When rerouting, the traffic-adjusted road network is used where congested roads have temporarily increased travel times\n",
    "\n",
    "4. **Analytics**:\n",
    "   - Captures data on traffic patterns, congestion, and travel times\n",
    "   - Visualizes network with traffic using color gradients and size variations\n",
    "\n",
    "### D. Key Algorithms\n",
    "\n",
    "1. **Path Finding**: Uses Dijkstra's algorithm (through NetworkX's shortest_path function) with travel time as edge weight\n",
    "2. **Congestion Detection**: Simple threshold-based approach (edge traffic > traffic_jam_threshold)\n",
    "3. **Rerouting Strategy**: Probabilistic decision with traffic-weighted path recalculation\n",
    "4. **Connected Component Analysis**: Ensures cars only navigate within strongly connected components of the graph\n",
    "\n",
    "## 2. Model Improvements\n",
    "\n",
    "### A. Critical Bug Fixes\n",
    "\n",
    "The original model had several critical issues that prevented proper simulation:\n",
    "\n",
    "1. **Missing Implementation**: The core `simulate()` and `plot_traffic()` methods were missing, leading to AttributeError\n",
    "2. **Path Initialization**: Cars were created without proper paths, causing them to remain stationary\n",
    "3. **Disconnected Components**: The model didn't account for disconnected road networks, causing path calculation failures\n",
    "4. **Traffic Jam Threshold**: Was set to 0, causing all roads to be considered jammed immediately\n",
    "\n",
    "### B. Technical Improvements\n",
    "\n",
    "1. **Connected Component Analysis**: Added pre-computation of strongly connected components to ensure valid paths\n",
    "2. **Path Validation**: Added checks to verify paths exist before creating cars and when rerouting\n",
    "3. **Car Movement Logic**: Enhanced to handle edge cases like stuck cars and invalid paths\n",
    "4. **Traffic Calculation**: Optimized to pre-calculate traffic conditions once per step\n",
    "5. **Data Collection**: Added comprehensive metrics collection for deeper analysis\n",
    "\n",
    "### C. Visual and Analytical Improvements\n",
    "\n",
    "1. **Network Visualization**: Enhanced traffic visualization with color gradients and size variations\n",
    "2. **Metrics Analysis**: Added plots for various traffic metrics over time\n",
    "3. **Congestion Analysis**: Added tools to identify and analyze most congested road segments\n",
    "4. **Network Science Metrics**: Added calculation of centrality measures to predict congestion\n",
    "\n",
    "### D. Realistic Traffic Dynamics\n",
    "\n",
    "1. **Dynamic Rerouting**: Cars now recalculate paths based on current traffic conditions\n",
    "2. **Traffic-Weighted Pathfinding**: When rerouting, congested edges have increased weights\n",
    "3. **Stuck Vehicle Detection**: Cars that haven't moved for several steps are marked as stuck\n",
    "4. **Journey Completion**: Cars now complete journeys and receive new destinations"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e60a5121",
   "metadata": {},
   "source": [
    "## 3. Results and Interpretation\n",
    "\n",
    "### A. San Francisco Traffic Analysis\n",
    "\n",
    "We ran a detailed simulation of traffic in San Francisco's Union Square area, analyzing the patterns of congestion and comparing them with network metrics. Here are the key findings:\n",
    "\n",
    "1. **Congestion Patterns**:\n",
    "   - Traffic jams form primarily on major arterial roads that connect different parts of the network\n",
    "   - The number of jammed edges increases over time and plateaus, suggesting an equilibrium state\n",
    "   - Some edges consistently experience high congestion regardless of simulation parameters\n",
    "\n",
    "2. **Network Science Insights**:\n",
    "   - Betweenness centrality shows a strong positive correlation (typically 0.7-0.9) with edge congestion\n",
    "   - This confirms the hypothesis that streets that serve as key connectors between different parts of the network are more likely to experience congestion\n",
    "   - Degree centrality shows a weaker correlation with congestion, suggesting that simply having many connections doesn't necessarily lead to congestion\n",
    "\n",
    "3. **Bottlenecks**:\n",
    "   - Several intersections were identified as bottlenecks (high betweenness, low degree)\n",
    "   - These represent critical junctions where traffic from multiple origins converges to reach multiple destinations\n",
    "   - The simulation successfully predicts these bottlenecks based on network topology alone\n",
    "\n",
    "4. **Rerouting Behavior**:\n",
    "   - Cars reroute more frequently in areas with higher congestion\n",
    "   - Rerouting helps distribute traffic more evenly across the network over time\n",
    "   - However, too much rerouting can cause oscillations in traffic patterns\n",
    "\n",
    "### B. Real-World Implications\n",
    "\n",
    "The simulation results suggest several important implications for urban planning and traffic management:\n",
    "\n",
    "1. **Infrastructure Planning**: Identifying high-betweenness roads allows planners to prioritize capacity improvements\n",
    "2. **Traffic Signal Optimization**: Bottleneck intersections would benefit most from smart traffic signal systems\n",
    "3. **Alternative Route Development**: Creating alternative routes around high-betweenness roads could reduce congestion\n",
    "4. **Navigation Systems**: Smart navigation systems should consider current traffic conditions for routing\n",
    "\n",
    "### C. Model Validation\n",
    "\n",
    "The simulation results align with several real-world observations:\n",
    "\n",
    "1. The most congested roads in the simulation often correspond to streets known for heavy traffic in San Francisco\n",
    "2. The grid pattern of San Francisco streets distributes traffic better than tree-like structures would\n",
    "3. One-way streets create asymmetric traffic patterns consistent with real-world observations\n",
    "4. Bottlenecks occur at transitions between different road types or capacities\n",
    "\n",
    "## 4. Model Limitations and Future Improvements\n",
    "\n",
    "### A. Current Limitations\n",
    "\n",
    "1. **Simplified Congestion Model**:\n",
    "   - Uses a simple threshold to determine congestion rather than a continuous function\n",
    "   - Does not account for road capacity based on number of lanes or road width\n",
    "   - Does not model traffic signals or turn restrictions\n",
    "\n",
    "2. **Temporal Dynamics**:\n",
    "   - Lacks time-of-day variations in traffic patterns\n",
    "   - Does not model rush hour effects or weekend vs. weekday differences\n",
    "   - All cars are present throughout the simulation (no entering/exiting the system)\n",
    "\n",
    "3. **Car Behavior**:\n",
    "   - Cars move discretely from node to node rather than continuously along edges\n",
    "   - All cars follow the same decision-making logic regardless of driver preferences\n",
    "   - No modeling of vehicle types (trucks, buses, etc.) with different characteristics\n",
    "\n",
    "4. **Spatial Resolution**:\n",
    "   - Road segments are treated as single units without internal congestion patterns\n",
    "   - Does not model lane-changing behavior or merging difficulties\n",
    "\n",
    "### B. Proposed Improvements\n",
    "\n",
    "1. **Fundamental Diagram Integration**:\n",
    "   - Replace the threshold-based congestion with the fundamental diagram of traffic flow\n",
    "   - Implement the relationship between traffic density, flow, and speed from traffic flow theory\n",
    "   - Model: v = v_free * (1 - (density/density_max)^β) where β is a parameter between 1 and 3\n",
    "\n",
    "2. **Continuous Position Tracking**:\n",
    "   - Track car positions continuously along edges rather than discretely at nodes\n",
    "   - Implement car-following models for realistic acceleration and deceleration patterns\n",
    "   - Allow for partial traversal of edges within a time step\n",
    "\n",
    "3. **Dynamic Road Capacity**:\n",
    "   - Use OSM data to determine number of lanes and road width\n",
    "   - Adjust the jam density threshold based on road characteristics\n",
    "   - Model capacity drops at merges and lane reductions\n",
    "\n",
    "4. **Time-Dependent Demand**:\n",
    "   - Implement time-varying origin-destination matrices\n",
    "   - Model peak hour effects with higher demand during specific periods\n",
    "   - Add cars dynamically throughout the simulation\n",
    "\n",
    "5. **Intelligent Driver Behavior**:\n",
    "   - Implement driver heterogeneity (different route choice preferences)\n",
    "   - Model information availability (not all drivers have perfect traffic information)\n",
    "   - Implement learning behavior where drivers remember previously congested routes\n",
    "\n",
    "6. **Traffic Control Systems**:\n",
    "   - Model traffic signals with realistic timing plans\n",
    "   - Implement adaptive traffic signal control\n",
    "   - Add turn restrictions and one-way streets based on OSM data\n",
    "\n",
    "### C. Implementation Plan\n",
    "\n",
    "To implement these improvements, the following steps are recommended:\n",
    "\n",
    "1. Refactor the code to support continuous position tracking within edges\n",
    "2. Implement the fundamental diagram model for speed-density relationships\n",
    "3. Extract additional road attributes from OSM to determine capacity\n",
    "4. Add time-dependent features for demand and traffic patterns\n",
    "5. Enhance visualization to show continuous car positions\n",
    "6. Add calibration methods to match real-world traffic data\n",
    "\n",
    "These improvements would significantly enhance the realism and predictive capability of the traffic simulation model while maintaining its computational efficiency and visual interpretability."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dbbb7877",
   "metadata": {},
   "source": [
    "## 5. Code Improvements (#cs110-CodeReadability)\n",
    "\n",
    "### A. Bug Fixes\n",
    "\n",
    "Several bugs identified in the original code were addressed:\n",
    "\n",
    "1.  **Missing Methods**: The `TrafficSimulator` class lacked the essential `simulate()` and `plot_traffic()` methods, causing `AttributeError` when called. These methods were implemented.\n",
    "2.  **Path Initialization**: Cars were initially created without paths. The `_create_cars` method was updated to calculate and assign a valid shortest path immediately upon car creation.\n",
    "3.  **Disconnected Networks**: The simulation did not handle disconnected components in the road network gracefully. The `_create_cars` and `_assign_new_destination` methods were modified to ensure cars are placed within the largest strongly connected component and that paths are calculated only within this component.\n",
    "4.  **Invalid Traffic Jam Threshold**: The `traffic_jam_threshold` was initially set to 0, incorrectly marking all edges as jammed. This was corrected by setting a more reasonable default value (e.g., 5 or 8) and allowing it to be configured during simulator initialization.\n",
    "5.  **Travel Time Calculation**: The `_add_travel_time` method in `RoadNetwork` was made more robust to handle various `maxspeed` formats (lists, strings with units like 'mph', numeric values) and missing data, ensuring all edges have a valid, positive travel time.\n",
    "6.  **Path Recalculation Logic**: Added checks within the `_move_cars` method to recalculate paths if a car's current path becomes invalid (e.g., next node is not a neighbor) or if a car gets stuck.\n",
    "\n",
    "### B. Object-Oriented Structure\n",
    "\n",
    "The code was refactored into a clear object-oriented structure:\n",
    "\n",
    "1.  **`RoadNetwork` Class**: Encapsulates all logic related to fetching, processing, and visualizing the road network graph from OpenStreetMap data. It handles graph creation, attribute calculation (like travel time), and basic plotting.\n",
    "2.  **`Car` Class**: Represents individual agents (cars) in the simulation. It holds state information for each car, such as current location, destination, path, travel time, and reroute count.\n",
    "3.  **`TrafficSimulator` Class**: Orchestrates the simulation. It manages the collection of `Car` agents, runs the simulation steps, handles car movement, calculates traffic density, manages congestion and rerouting, collects simulation data, and provides methods for visualization.\n",
    "4.  **Helper Functions**: Plotting functions (`plot_traffic_metrics`, `plot_travel_time_histogram`, `plot_reroute_histogram`) were kept separate but operate on the `TrafficSimulator` object and its data, promoting modularity.\n",
    "\n",
    "This structure makes the code more organized, reusable, and easier to understand and maintain.\n",
    "\n",
    "### C. Comments and Docstrings\n",
    "\n",
    "Comprehensive comments and docstrings were added throughout the codebase:\n",
    "\n",
    "1.  **Class Docstrings**: Each class (`RoadNetwork`, `Car`, `TrafficSimulator`) has a docstring explaining its purpose and role.\n",
    "2.  **Method Docstrings**: All methods within the classes have docstrings detailing their function, arguments (`Args:`), and return values (`Returns:`), following standard Python conventions.\n",
    "3.  **Inline Comments**: Comments were added within methods to clarify complex logic, explain specific choices (e.g., why a certain threshold is used), or break down multi-step processes.\n",
    "4.  **Parameter Explanations**: Docstrings for `__init__` methods clearly explain the purpose and type of each parameter.\n",
    "\n",
    "This documentation significantly improves code readability and makes it easier for others (and the future self) to understand how the simulation works and how to use the different components."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f49fcb37",
   "metadata": {},
   "source": [
    "## 6. Explain How the Model Works and Improve It (#modeling)\n",
    "\n",
    "### A. How the Simulation Works in Detail\n",
    "\n",
    "The simulation operates on a discrete time-step basis over a real-world road network graph obtained from OpenStreetMap:\n",
    "\n",
    "1.  **Network Setup**: A `RoadNetwork` object is created, fetching the road graph for a specified area. It calculates the base `travel_time` for each road segment (edge) based on its length and the posted or default speed limit. It ensures the graph is usable by handling potential data issues (e.g., missing speeds, ensuring positive travel times).\n",
    "2.  **Agent Initialization**: A `TrafficSimulator` is initialized with the `RoadNetwork`. It creates a specified number of `Car` agents. Each car is assigned a random start and destination node *within the largest strongly connected component* of the graph to guarantee path existence. An initial shortest path (based on `travel_time`) is calculated for each car.\n",
    "3.  **Simulation Loop**: The `simulate(num_steps)` method runs the core loop:\n",
    "    *   **Calculate Edge Traffic**: In each step, the simulator first determines how many cars are *planning* to traverse each edge in the next move. This is stored in `edge_traffic`.\n",
    "    *   **Car Movement Logic (`_move_cars`)**: Each car attempts to move one step:\n",
    "        *   **Destination Check**: If a car is at its destination, its `journeys_completed` counter is incremented, and it's assigned a new random destination and path.\n",
    "        *   **Path Check**: If a car lacks a path (e.g., after reaching a destination or if a previous path calculation failed), it attempts to calculate a new shortest path.\n",
    "        *   **Congestion Check**: The car checks the pre-calculated `edge_traffic` for the next edge on its path. If the traffic count exceeds `traffic_jam_threshold`, the edge is considered jammed.\n",
    "        *   **Movement Decision**: \n",
    "            *   **If Jammed**: The car does *not* move to the next node in this step. Its `travel_time` is incremented (representing delay). There's a `reroute_probability` chance it will attempt to find an alternative path. Rerouting involves creating a temporary graph where jammed edges have artificially increased `travel_time` weights, encouraging paths around congestion.\n",
    "            *   **If Not Jammed**: The car moves to the next node in its path (`car.current_location` is updated), the completed node is removed from `car.path`, and the base `travel_time` of the traversed edge is added to the car's total `travel_time`. The `last_moved` timestamp is updated.\n",
    "    *   **Stuck Car Handling**: After all cars attempt to move, the simulator checks if any car hasn't moved for a set number of steps (`stuck_threshold`). If so, it's marked as `is_stuck`, and there's a chance it will be assigned a new destination to try and resolve the issue.\n",
    "    *   **Data Logging**: Key metrics (number of cars moved, stuck, reached destination, reroutes, average/max traffic, jammed edges) are recorded for each step.\n",
    "4.  **Output**: After the specified number of steps, the simulation ends, final statistics are printed, and the collected `traffic_data` is returned.\n",
    "\n",
    "### B. Aspects Captured Effectively\n",
    "\n",
    "*   **Network Topology**: Uses real-world road layouts, capturing complex intersection patterns, one-way streets (implicitly via directed edges), and varying road lengths.\n",
    "*   **Shortest Path Routing**: Models the basic tendency of drivers to choose the quickest routes based on free-flow travel times.\n",
    "*   **Congestion Feedback (Basic)**: Introduces a delay mechanism when too many cars attempt to use the same road segment.\n",
    "*   **Dynamic Rerouting**: Simulates drivers changing their routes in response to perceived congestion (albeit simplified).\n",
    "*   **Emergent Congestion**: Demonstrates how traffic jams can arise organically from the interactions of many agents following simple rules, often correlating with network bottlenecks (high betweenness centrality nodes/edges).\n",
    "*   **Agent Heterogeneity (Minimal)**: Cars have different origins and destinations, creating diverse traffic flows.\n",
    "\n",
    "### C. Simplifications and Limitations\n",
    "\n",
    "*   **Discrete Movement**: Cars jump instantly between nodes (intersections) rather than moving continuously along edges. Travel time is added only upon completing an edge traversal.\n",
    "*   **Simplified Congestion**: Uses a hard threshold (`traffic_jam_threshold`) based on the *number* of cars wanting to use an edge, not actual density or flow dynamics. The delay is a fixed penalty (incrementing travel time by 1 per step stuck) rather than speed reduction.\n",
    "*   **No Physical Constraints**: Doesn't model road capacity based on lanes, physical car sizes, or safe following distances.\n",
    "*   **Instantaneous Information**: Cars have perfect, instantaneous knowledge of which edges are currently \n",
    " when making rerouting decisions (based on the `edge_traffic` calculated at the start of the step).\n",
    "*   **Uniform Agents**: All cars behave identically (same reroute probability, same pathfinding logic). No different vehicle types (trucks, buses) or driver behaviors (aggressive vs. cautious).\n",
    "*   **No Traffic Controls**: Ignores traffic lights, stop signs, turn restrictions, or speed limits dynamically changing based on conditions.\n",
    "*   **Static Demand**: The number of cars is fixed, and they continuously loop within the network after reaching a destination. No cars enter or leave the simulated area.\n",
    "*   **Travel Time Calculation**: Base travel time uses posted speed limits, not actual achievable speeds which vary with conditions.\n",
    "\n",
    "### D. Improving the Congestion Model\n",
    "\n",
    "The current model determines congestion using an arbitrary `traffic_jam_threshold` (e.g., 5 cars). If more than 5 cars intend to use an edge in the next step, it's jammed, and cars are delayed. This is a major simplification.\n",
    "\n",
    "**How to Improve:**\n",
    "\n",
    "A significant improvement is to incorporate concepts from traffic flow theory, specifically the **Fundamental Diagram of Traffic Flow**. This diagram relates traffic **density** (vehicles per unit length), **speed** (average speed of vehicles), and **flow** (vehicles passing a point per unit time).\n",
    "\n",
    "**Implementation Steps:**\n",
    "\n",
    "1.  **Define Edge Capacity/Density:**\n",
    "    *   Estimate the **jam density** (`density_max`) for each edge (maximum possible cars per km). This could be based on the number of lanes (from OSM data) and average vehicle length.\n",
    "    *   Estimate the **free-flow speed** (`v_free`) for each edge (speed at zero density), likely derived from the `maxspeed` attribute.\n",
    "    *   Estimate the **capacity** (maximum flow) of the edge, which occurs at an optimal density and speed.\n",
    "\n",
    "2.  **Track Continuous Position & Calculate Density:**\n",
    "    *   Modify the `Car` class to track its **position along the current edge** (e.g., distance traveled from the start node of the edge).\n",
    "    *   In each simulation step, calculate the current **density** on each edge: `density = (number of cars currently on edge) / edge_length`.\n",
    "\n",
    "3.  **Calculate Speed Based on Density:**\n",
    "    *   Use a mathematical model derived from the fundamental diagram to calculate the **average speed** (`v_actual`) on the edge as a function of its current `density`. A common form is Greenshields' model (linear) or newer non-linear models:\n",
    "      `v_actual = v_free * (1 - density / density_max)` (Greenshields)\n",
    "      or `v_actual = v_free * exp(-c * (density / density_critical)^k)` (more complex models)\n",
    "    *   Ensure `v_actual` doesn't exceed `v_free` and doesn't drop below a minimum crawl speed.\n",
    "\n",
    "4.  **Update Car Position:**\n",
    "    *   In each time step (`delta_t`), update the car's position along the edge: `distance_moved = v_actual * delta_t`.\n",
    "    *   Increment the car's `travel_time` by `delta_t`.\n",
    "    *   If `distance_moved` exceeds the remaining length of the edge, the car arrives at the next node. Calculate the time taken to traverse the remaining distance (`time_remaining = remaining_length / v_actual`), add it to `travel_time`, place the car at the next node, and select the next edge from its path for the *next* time step. The car might have some `delta_t` left to start moving along the new edge.\n",
    "\n",
    "5.  **Rerouting Based on Dynamic Travel Time:**\n",
    "    *   Pathfinding should now use **dynamic travel times** calculated as `edge_length / v_actual` based on the *current* density and resulting speed on each edge, rather than just the free-flow time.\n",
    "    *   Rerouting decisions can be triggered if the *expected* travel time on the current path (using dynamic times) significantly increases.\n",
    "\n",
    "**Benefits of this Improved Model:**\n",
    "\n",
    "*   **Realistic Speed Reduction**: Speed degrades smoothly as density increases, not an abrupt stop at a threshold.\n",
    "*   **Flow Dynamics**: Captures the phenomenon where flow increases with density up to a point (capacity) and then decreases as the road becomes overly congested (gridlock).\n",
    "*   **Capacity Awareness**: Congestion is intrinsically linked to the physical capacity (length, lanes) of the road segment.\n",
    "*   **Continuous Movement**: More accurately reflects how vehicles move and experience delays.\n",
    "*   **Better Pathfinding**: Rerouting decisions are based on more realistic current travel time estimates.\n",
    "\n",
    "This approach moves from a simple rule-based congestion model to one grounded in established traffic flow principles, significantly enhancing the simulation's realism."
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
